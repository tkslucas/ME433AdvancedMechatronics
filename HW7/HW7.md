## Old Display video

[2020 video about the display](https://www.youtube.com/watch?v=F6LFSSA6TWw)  

## I2C OLED display

The [SSD1306](https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf) is a driver for OLED displays. We will use a [128x32 pixel I2C breakout board](https://amzn.to/3LloIWX) version. An OLED display uses individually controllable LEDs as pixels, so it does not need a backlight like a TFT LCD (like on most computer and cellphone screens).  

The pixels can either be on or off, so there is no control over individual color or brightness. That means the amount of memory it takes to know every pixels value is 128 x 32 = 4096 bits = 512 bytes. That is a very reasonable amount of memory (compared to a color display, which would need 3 color bytes, RGB, per pixel, or  128 x 32 x 3 = 12288 bytes, and that's not a very high resolution display!). So what we'll be able to do is store the value of every pixel inside of an array in the Pico, and update all of the pixels simultaneously to update the display.  

This display has 3 downsides: low resolution, relatively slow I2C communication compared to SPI, and no reset pin. The SSD1306 can communicate with SPI, and it has a reset pin, but this particular breakout board did not make those available, so we'll have to use I2C and a heartbeat to know if the communication is stuck.  

Take a look at the [SSD1306 sample code](https://github.com/ndm736/ME433_2025/tree/main/ssd1306) which uses the functions from the SDK I2C sample code. I referenced code written for various Arduino boards to figure out how to initialize the registers to make the display turn on, those are set using ssd1306_setup(). The setup function contains a short delay at the beginning, the display seems to need a little time to settle after getting power before you start talking to it.  

Add ssd1306.c, ssd1306.h, and font.h to your project folder. You need to add ssd1306.c to CMakeLists.txt in add_executable() for the library to be compiled.  

The ssd1306.c file contains an array of 513 unsigned chars. The first byte is a command. For the rest for the bytes, the bits in this array represent what the display will show when you call the ssd1306_update() function. Update with the default I2C baud takes about 1/80th of a second, which is fine for our purposes, but considering the low resolution of the screen it isn't really too impressive.  

ssd1306.c contains two other functions, ssd1306_clear() and ssd1306_drawPixel(). clear() sets the value of every pixel to off. drawPixel() takes the x and y location of a pixel and turns it on (1) or off (0). These functions only change the memory inside of the Pico, you must call ssd1306_update() to push the data to the display.  

That's all you get! No method for drawing lines, circles, or text, just drawing individual pixels and updating the display. It is your job to make this more useful by adding a function to draw text so that we can see the values of variables. 

## Assignment 

First, connect SDA and SCL to your I2C bus, and Vdd to 3.3V and GND to GND (the breakout board already has the pullup resistors). Start a new project and put it in a folder in your repo called HW7. Use the I2C and the ssd1306 sample code from this repo to initialize I2C, initialize the ssd1306, and blink both a LED and a pixel at 1Hz to verify that your setup works. Keep the LED blink in your code, it is useful as a heartbeat to know that the Pico is not frozen, which can happen if the Pico is communicating with the ssd1306 when you happen to reset and then the ssd1306 never communicates with the Pico again without a power reset.  

Second, write a function that uses the [font sample code](https://github.com/ndm736/ME433_2025/blob/main/ssd1306/font.h) to draw a letter at a (x,y) position. The function should take in the position of the letter in x and y, and the character. font.h contains a bitmap of every drawable character in ASCII, starting with the space character at 0x20. Each letter is 8 pixels tall and 5 pixels wide. Loop through the matrix ASCII[the letter][column 0 to 4], turning pixels on when the bit is a 1 and off when the bit is a 0. Test it out.  

Third, write a function that prints a character array generated by sprintf() at a position. The function should take in the position of the first letter in x and y, and a pointer to the character array. In the function, while the character is not the null character ('\0' or the value 0) send the character to your draw letter function with the right x and y position. Now you can make a message and write to the screen:  

```c
int i = 15;
char message[50]; 
sprintf(message, "my var = %d", i); 
drawMessage(20,10,message); // draw starting at x=20,y=10  
```

Every letter is 5x8 pixels, and the screen is 128x32, so you can fit 25x4 letters on the screen! Test your function by filling up the screen.  

Finally, **write a program that prints the value of ADC0 in volts.** Print at the bottom of the screen the frames per second (fps) that the display achieves.  

The number of microseconds since the Pico has turned on can be accessed with:

```c
unsigned int t = to_us_since_boot(get_absolute_time());  
```

Submit a link to the HW7 folder in your repo in Canvas and make a demonstration video of the display and upload that to Canvas.  